From 0f6605d101703e62cc17fc2fc15d2fcabfa7f481 Mon Sep 17 00:00:00 2001
From: Zhang Owen <owen.zhang@intel.com>
Date: Wed, 10 Jul 2019 14:05:00 +0800
Subject: [PATCH 1/5] IOMMU support for vca modules

IOMMU-Adding domain mapping for all slots of NTB bus
Apply VCA IOMMU workaround to host NTB devices

Change-Id: I10f764a3263c2ddcdebdbd3de8d6716ca0902460
---
 drivers/iommu/intel-iommu.c | 36 +++++++++++++++++++++++++++++++++++-
 drivers/pci/quirks.c        | 16 ++++++++++++++++
 include/linux/pci.h         |  1 +
 3 files changed, 52 insertions(+), 1 deletion(-)

diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c
index 49b2664..607307d 100644
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@ -2096,6 +2096,36 @@ out_unlock:
 	return ret;
 }
 
+static int add_ntb_mapping(
+	struct dmar_domain *domain,
+	struct intel_iommu *iommu,
+	u8 bus,
+	const struct pci_dev *pdev)
+{
+	unsigned int slot, func;
+	int ret;
+	const unsigned num_pci_slots = 0x20;
+	const unsigned num_pci_funcs = 0x8;
+
+	for (slot = 0; slot < num_pci_slots; slot++) {
+		for (func = 0; func < num_pci_funcs; func++) {
+			if ((ret = domain_context_mapping_one(domain, iommu, bus,
+					PCI_DEVFN(slot, func)))) {
+				pr_err("IOMMU-NTB: error mapping domains for "
+					"NTB [bus: 0x%x devfn: 0x%x]: %x\n",
+					bus,  (unsigned)PCI_DEVFN(slot, func),
+					ret);
+				return ret;
+			}
+			pr_debug("IOMMU-NTB: mapping domains for NTB "
+				 "[bus: 0x%x devfn: 0x%x]\n", bus,
+				 (unsigned)PCI_DEVFN(slot, func));
+		}
+	}
+
+	return ret;
+}
+
 struct domain_context_mapping_data {
 	struct dmar_domain *domain;
 	struct intel_iommu *iommu;
@@ -2106,8 +2136,12 @@ static int domain_context_mapping_cb(struct pci_dev *pdev,
 {
 	struct domain_context_mapping_data *data = opaque;
 
-	return domain_context_mapping_one(data->domain, data->iommu,
+	if (!pdev->is_ntb)
+		return domain_context_mapping_one(data->domain, data->iommu,
 					  PCI_BUS_NUM(alias), alias & 0xff);
+	else
+		return add_ntb_mapping(data->domain, data->iommu,
+					PCI_BUS_NUM(alias), pdev);
 }
 
 static int
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index 5160a78..8fed542 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -3872,6 +3872,22 @@ static int pci_quirk_amd_sb_acs(struct pci_dev *dev, u16 acs_flags)
 }
 
 /*
+ * VCA accelerator uses non-transparent bridge, need to handle requester ID
+ * translation for PCI transactions.
+ */
+static void quirk_plx_vca(struct pci_dev *dev)
+{
+	dev->is_ntb=1;
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2954, quirk_plx_vca);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2955, quirk_plx_vca);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2956, quirk_plx_vca);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2958, quirk_plx_vca);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2959, quirk_plx_vca);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x295A, quirk_plx_vca);
+
+/*
  * Many Intel PCH root ports do provide ACS-like features to disable peer
  * transactions and validate bus numbers in requests, but do not provide an
  * actual PCIe ACS capability.  This is the list of device IDs known to fall
diff --git a/include/linux/pci.h b/include/linux/pci.h
index b3605de..b88ccbd 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -278,6 +278,7 @@ struct pci_dev {
 	u8		pcie_mpss:3;	/* PCIe Max Payload Size Supported */
 	u8		rom_base_reg;	/* which config register controls the ROM */
 	u8		pin;		/* which interrupt pin this device uses */
+	u8		is_ntb;		/* is this a non-transparent bridge device? */
 	u16		pcie_flags_reg;	/* cached PCIe Capabilities Register */
 	u8		dma_alias_devfn;/* devfn of DMA alias, if any */
 
-- 
1.8.3.1

